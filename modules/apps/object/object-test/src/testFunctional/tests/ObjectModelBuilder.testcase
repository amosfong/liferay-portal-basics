@component-name = "portal-bpm"
definition {

	property portal.release = "true";
	property portal.upstream = "true";
	property testray.main.component.name = "Object";

	setUp {
		TestCase.setUpPortalInstance();

		User.firstLoginPG();
	}

	tearDown {
		ObjectAdmin.deleteAllCustomObjectsViaAPI();

		var testLiferayVirtualInstance = PropsUtil.get("test.liferay.virtual.instance");

		if (${testLiferayVirtualInstance} == "true") {
			PortalInstances.tearDownCP();
		}
	}

	@description = "LPS-148856 - Verify an error message is seen when attempting to publish invalid object definitions in model builder view"
	@priority = 5
	test CannotPublishObjectDefinitionsWithErrors {
		task ("Given a custom object definition with a decimal field, Object A") {
			ObjectAdmin.addObjectViaAPI(
				labelName = "Custom Object 198013 A",
				objectName = "CustomObject198013A",
				pluralLabelName = "Custom Objects 198013 A");

			ObjectAdmin.addObjectFieldViaAPI(
				fieldBusinessType = "Decimal",
				fieldLabelName = "Custom Decimal Field",
				fieldName = "customDecimalField",
				fieldType = "Double",
				isRequired = "false",
				objectName = "CustomObject198013A");
		}

		task ("and Given two custom object definitions without any custom fields, Object B and Object C") {
			for (var letter : list "B,C") {
				ObjectAdmin.addObjectViaAPI(
					labelName = "Custom Object 198013 ${letter}",
					objectName = "CustomObject198013${letter}",
					pluralLabelName = "Custom Objects 198013 ${letter}");
			}
		}

		task ("and Given the user is in the model builder view") {
			ObjectModelBuilder.openObjectFolderInModelBuilder();
		}

		task ("When the user publishes all of the custom object definitions") {
			Button.clickPublish();

			for (var objectDefinitionName : list "Custom Object 198013 A,Custom Object 198013 B,Custom Object 198013 C") {
				Check.checkNotVisible(
					locator1 = "ObjectModelBuilder#CONFIRM_PUBLISHING_OBJECT_DEFINITION_INPUT",
					objectDefinition = ${objectDefinitionName});
			}

			Click(
				key_text = "Publish Objects",
				locator1 = "Modal#MODAL_FOOTER_BUTTON");
		}

		task ("Then two error messages are seen and Object B and Object C aren't published") {
			for (var letter : list "B,C") {
				AssertTextEquals(
					locator1 = "ObjectModelBuilder#OBJECT_REJECTED_ERROR_MESSAGE",
					objectDefinition = "Custom Object 198013 ${letter}",
					value1 = "At least one object field must be added.");
			}
		}

		task ("and Then Object A is published") {
			AssertVisible(
				labelText = "Approved",
				locator1 = "ObjectModelBuilder#OBJECT_CARD_LABEL",
				objectDefinition = "Custom Object 198013 A");
		}
	}

	@description = "LPS-148856 - Verify multiple custom object definitions can be published"
	@priority = 5
	test CanPublishMultipleObjectDefinitions {
		task ("Given three custom object definitions that contains long text fields") {
			for (var letter : list "A,B,C") {
				ObjectAdmin.addObjectViaAPI(
					labelName = "Custom Object 197932 ${letter}",
					objectName = "CustomObject197932${letter}",
					pluralLabelName = "Custom Objects 197932 ${letter}");

				ObjectAdmin.addObjectFieldViaAPI(
					fieldBusinessType = "LongText",
					fieldLabelName = "Custom Field",
					fieldName = "customObjectField",
					fieldType = "Clob",
					isRequired = "false",
					objectName = "CustomObject197932${letter}");
			}
		}

		task ("and Given the user is in the model builder view") {
			ObjectAdmin.openObjectAdmin();

			ObjectModelBuilder.openObjectFolderInModelBuilder();
		}

		task ("When the user publishes two custom object definitions") {
			ObjectModelBuilder.publishObjectDefinitions(objectDefinitionsList = "Custom Object 197932 A,Custom Object 197932 B");
		}

		task ("Then two object definitions are published and one remains in draft status") {
			AssertVisible(
				labelText = "Approved",
				locator1 = "ObjectModelBuilder#OBJECT_CARD_LABEL",
				objectDefinition = "Custom Object 197932 A");

			AssertVisible(
				labelText = "Approved",
				locator1 = "ObjectModelBuilder#OBJECT_CARD_LABEL",
				objectDefinition = "Custom Object 197932 B");

			AssertVisible(
				labelText = "Draft",
				locator1 = "ObjectModelBuilder#OBJECT_CARD_LABEL",
				objectDefinition = "Custom Object 197932 C");
		}
	}

	@description = "LPS-185674 - Verify the user is able to search for a specific object definition in model builder view"
	@priority = 4
	test CanSearchForObjectDefinition {
		task ("Given an user in model builder view") {
			ObjectModelBuilder.openObjectFolderInModelBuilder();
		}

		task ("When the user searches for Account") {
			Search.searchCP(searchTerm = "Account");
		}

		task ("Then only Account is seen") {
			for (var objectLabel : list "Postal Address,Commerce Product,Organization,User,Commerce Order,Commerce Product") {
				AssertElementNotPresent(
					key_folderLabel = "Default",
					key_objectLabel = ${objectLabel},
					locator1 = "ObjectModelBuilder#SELECT_OBJECT_IN_LEFT_SIDEBAR");

				AssertElementPresent(
					key_folderLabel = "Default",
					key_objectLabel = "Account",
					locator1 = "ObjectModelBuilder#SELECT_OBJECT_IN_LEFT_SIDEBAR");
			}
		}
	}

	@description = "LPS-185676 - Verify when the user searches for an object definition, the current object folder is displayed first and other folders are in alphabetical order"
	@priority = 3
	test CanSearchForObjectDefinitionWithRelationship {
		task ("Given an object definition called Employee in the Employee folder") {
			var employeeFolderERC = JSONObjectFolder.addFolder(
				folderLabel = "Employee",
				folderName = "Employee");

			ObjectAdmin.addObjectViaAPI(
				labelName = "Employee",
				objectName = "Employee",
				pluralLabelName = "Employees");

			JSONObject.updateObject(
				configKey = "objectFolderExternalReferenceCode",
				configValue = ${employeeFolderERC},
				objectName = "Employee");
		}

		task ("and Given an object definition called Role in the Role folder") {
			var roleFolderERC = JSONObjectFolder.addFolder(
				folderLabel = "Role",
				folderName = "Role");

			ObjectAdmin.addObjectViaAPI(
				labelName = "Role",
				objectName = "Role",
				pluralLabelName = "Roles");

			JSONObject.updateObject(
				configKey = "objectFolderExternalReferenceCode",
				configValue = ${roleFolderERC},
				objectName = "Role");
		}

		task ("and Given an object definition called Department in the Department folder") {
			var departmentFolderERC = JSONObjectFolder.addFolder(
				folderLabel = "Department",
				folderName = "Department");

			ObjectAdmin.addObjectViaAPI(
				labelName = "Department",
				objectName = "Department",
				pluralLabelName = "Departments");

			JSONObject.updateObject(
				configKey = "objectFolderExternalReferenceCode",
				configValue = ${departmentFolderERC},
				objectName = "Department");
		}

		task ("and Given Employee is related to Role and Department") {
			ObjectAdmin.addObjectRelationshipViaAPI(
				objectName_1 = "Employee",
				objectName_2 = "Role",
				relationshipLabel = "EmployeeRoles",
				relationshipName = "employeeRoles",
				relationshipType = "manyToMany");

			ObjectAdmin.addObjectRelationshipViaAPI(
				objectName_1 = "Department",
				objectName_2 = "Employee",
				relationshipLabel = "DepartmentEmployees",
				relationshipName = "departmentEmployees",
				relationshipType = "oneToMany");
		}

		task ("and Given the user is in the Employee folder") {
			ObjectModelBuilder.openObjectFolderInModelBuilder(objectFolderName = "Employee");
		}

		task ("When the user searches for Employee in the side panel") {
			Search.searchCP(searchTerm = "Employee");
		}

		task ("Then the Employee folder is displayed as the first result") {
			AssertElementPresent(
				key_folderLabel = "Employee",
				key_index = 1,
				locator1 = "ObjectModelBuilder#SIDEBAR_FOLDER_BY_INDEX");
		}

		task ("And Then Department and Role are listed in alphabetical order with Employee listed in them with the link icon") {
			AssertElementPresent(
				key_index = 2,
				locator1 = "ObjectModelBuilder#SIDEBAR_FOLDER_BY_INDEX",
				value1 = "Department");

			AssertElementPresent(
				key_folderLabel = "Department",
				key_objectLabel = "Employee",
				locator1 = "ObjectModelBuilder#LINKED_OBJECT_IN_OTHER_FOLDERS");

			AssertElementPresent(
				key_index = 3,
				locator1 = "ObjectModelBuilder#SIDEBAR_FOLDER_BY_INDEX",
				value1 = "Role");

			AssertElementPresent(
				key_folderLabel = "Role",
				key_objectLabel = "Employee",
				locator1 = "ObjectModelBuilder#LINKED_OBJECT_IN_OTHER_FOLDERS");
		}
	}

	@description = "LPS-185679 - Verify the user can update a field in model builder view"
	@priority = 5
	test CanUpdateField {
		task ("Given a custom object definition with a rich text field") {
			ObjectAdmin.addObjectViaAPI(
				labelName = "Custom Object 199362",
				objectName = "CustomObject199362",
				pluralLabelName = "Custom Objects 199362");

			ObjectAdmin.addObjectFieldViaAPI(
				fieldBusinessType = "RichText",
				fieldLabelName = "Rich Text Field",
				fieldName = "richTextField",
				fieldType = "Clob",
				isRequired = "false",
				objectName = "CustomObject199362");

			ObjectAdmin.publishObjectViaAPI(objectName = "CustomObject199362");
		}

		task ("and Given the user is in model builder view") {
			ObjectModelBuilder.openObjectFolderInModelBuilder();
		}

		task ("When the user edits the label of the field in the right sidebar") {
			ObjectModelBuilder.selectObjectNode(objectLabel = "Custom Object 199362");

			Click(
				key_text = "Show All Fields",
				locator1 = "Button#ANY_LAST");

			Click(
				fieldLabel = "Rich Text Field",
				locator1 = "ObjectModelBuilder#OBJECT_FIELD_NODE");

			Type(
				key_fieldLabel = "Label",
				locator1 = "TextInput#GENERIC_TEXT_INPUT",
				value1 = "Rich Text Field Updated");

			Click(locator1 = "ObjectField#NAME_FIELD_DISABLED");
		}

		task ("Then the rich text field is updated") {
			AssertElementPresent(locator1 = "ObjectModelBuilder#MODEL_BUILDER_CHANGES_SAVED");

			AssertElementPresent(
				key_fieldValue = "Rich Text Field Updated",
				locator1 = "FormFields#TEXT_FIELD_3");
		}
	}

	@description = "LPS-185676 - Verify the object definition cards persist after the relationship is deleted"
	@priority = 3
	test CanViewCardAfterRelationshipDeletion {
		task ("Given a relationship between two object definitions in the same folder") {
			var objectFolderERC = JSONObjectFolder.addFolder(
				folderLabel = "Custom Folder 198088",
				folderName = "CustomFolder198088");

			for (var object : list "981,088") {
				ObjectAdmin.addObjectViaAPI(
					labelName = "Custom Object ${object}",
					objectName = "CustomObject${object}",
					pluralLabelName = "Custom Objects ${object}");

				JSONObject.updateObject(
					configKey = "objectFolderExternalReferenceCode",
					configValue = ${objectFolderERC},
					objectName = "CustomObject${object}");
			}

			ObjectAdmin.addObjectRelationshipViaAPI(
				objectName_1 = "CustomObject981",
				objectName_2 = "CustomObject088",
				relationshipLabel = "Relationship",
				relationshipName = "relationship",
				relationshipType = "oneToMany");
		}

		task ("When the user deletes the relationship") {
			ObjectModelBuilder.openObjectFolderInModelBuilder(objectFolderName = "CustomFolder198088");

			Click(
				key_connectorLabel = "Relationship",
				locator1 = "ProcessBuilderKaleoDesignerReact#DIAGRAM_CONNECTOR_LABEL");

			ClickNoError(locator1 = "Button#TRASH_ENABLED");

			Type(
				locator1 = "ObjectAdmin#PLACEHOLDER_DELETE_RELATIONSHIP",
				value1 = "relationship");

			Click(locator1 = "Form#SIDEBAR_DELETE_FIELD_MODAL_DELETE_BUTTON");
		}

		task ("Then the relationship is deleted and the object definition cards persist") {
			AssertElementNotPresent(
				key_connectorLabel = "Relationship",
				locator1 = "ProcessBuilderKaleoDesignerReact#DIAGRAM_CONNECTOR_LABEL");

			AssertElementPresent(
				locator1 = "ObjectModelBuilder#OBJECT_DEFINITION_NODE",
				objectLabel = "Custom Object 981");

			AssertElementPresent(
				locator1 = "ObjectModelBuilder#OBJECT_DEFINITION_NODE",
				objectLabel = "Custom Object 088");
		}
	}

}